### <a name="_b7urdng99y53"></a>**Название задачи:**
Просмотр истории покупок

### <a name="_hjk0fkfyohdk"></a>**Автор:**
Степанов Андрей

### <a name="_uanumrh8zrui"></a>**Дата:**
2026-01-28

---

### <a name="_3bfxc9a45514"></a>**Функциональные требования**

Определяем верхнеуровневые Use Cases для сценария "История покупок" в личном кабинете покупателя.

| **№** | **Действующие лица или системы** | **Use Case** | **Описание** |
|:-:|:---|:---|:---|                                      
| **UC-H1** | **Покупатель**       | **Просмотр списка заказов**       | Покупатель открывает раздел "История заказов" в личном кабинете. Система отображает список всех его заказов, отсортированный по дате (новые сверху). Для каждого заказа отображается краткая информация: номер, дата, статус, общая стоимость и ключевые товары. |
| **UC-H2** | **Покупатель**       | **Просмотр деталей конкретного заказа** | Покупатель выбирает конкретный заказ из списка. Система отображает полную детализацию заказа: полный список товаров с ценами, итоговую сумму, информацию о доставке (адрес, способ, трек-номер), историю статусов и историю платежей. |
| **UC-H3** | **Покупатель**       | **Фильтрация и поиск в истории заказов** | Покупатель использует фильтры (по периоду, статусу, сумме) или поиск по номеру заказа / названию товара для быстрого нахождения нужных заказов.                                                                                            |
| **UC-H4** | **Покупатель**       | **Повтор заказа (Reorder)**        | Покупатель выбирает один из предыдущих заказов и нажимает "Повторить заказ". Система добавляет все товары из этого заказа в текущую корзину покупателя для последующего оформления.                                                       |
| **UC-H5** | **Orders History Service** | **Агрегация данных о заказе**      | Сервис истории заказов подписан на события из шины (`Event Bus`). При получении событий `OrderCreated`, `OrderStatusChanged`, `PaymentSucceeded`, `DeliveryStatusChanged` и т.д., он обновляет денормализованное представление заказа в своей базе данных (`ClickHouse`). |
| **UC-H6** | **Orders History Service** | **Обогащение данных о товарах в истории** | Сервис подписан на событие `ProductUpdated`. При изменении названия товара или его атрибутов, сервис обновляет соответствующую информацию в сохраненных исторических записях заказов, чтобы отображать актуальные названия, даже если товар был переименован. |

---

### **Спецификация сценариев (детализация)**

#### **UC-H1: Просмотр списка заказов**
1.  **Триггер:** Покупатель переходит в раздел "Мои заказы" в личном кабинете приложения.
2.  **Основной поток:**
    1.  Приложение (`SPA`) отправляет запрос к `API Gateway`.
    2.  `API Gateway` маршрутизирует запрос к `Orders History Service`.
    3.  `Orders History Service` запрашивает из `Orders History DB` агрегированные данные по заказам, отфильтрованные по ID покупателя и отсортированные по дате создания.
    4.  Сервис возвращает структурированный ответ.
    5.  Приложение отображает список заказов в интерфейсе.

#### **UC-H2: Просмотр деталей конкретного заказа**
1.  **Триггер:** Покупатель нажимает на карточку заказа в общем списке.
2.  **Основной поток:**
    1.  Приложение отправляет запрос к `API Gateway` с уникальным идентификатором заказа.
    2.  `API Gateway` маршрутизирует запрос к `Orders History Service`.
    3.  `Orders History Service` извлекает из своей БД полный денормализованный "снимок" (snapshot) выбранного заказа, включая все товары, статусы, платежи и доставку.
    4.  Сервис возвращает детальную информацию.
    5.  Приложение отображает страницу с подробностями заказа.

#### **UC-H5: Агрегация данных о заказе (Фоновый процесс)**
1.  **Триггер:** В шину событий (`Kafka`) публикуется событие, связанное с жизненным циклом заказа (например, `OrderCreated` от `Order Service`).
2.  **Основной поток:**
    1.  `Orders History Service`, являясь подписчиком на эти события, получает новое событие.
    2.  Сервис десериализует событие и извлекает из него данные (ID заказа, статус, список товаров и т.д.).
    3.  Сервис обновляет или создает запись в `Orders History DB` (`ClickHouse`), агрегируя данные из разных событий в единую денормализованную структуру, удобную для чтения.
    4.  Данные в истории заказов становятся актуальными.

---

### **Нерелевантные для истории покупок Use Cases (из схемы)**

*   **Управление корзиной (Cart Service)**
*   **Оформление нового заказа (Order Service, Saga)**
*   **Обработка платежа (Payment Service)**
*   **Управление остатками (Inventory Service)**
*   **Организация доставки (Delivery Service)**
*   **Работа с каталогом (Catalog Services)**

Эти сценарии являются источником событий для `Orders History Service`, но сами по себе не являются частью пользовательского сценария "Просмотр истории заказов". Они включены в общую схему для понимания контекста и потоков данных.

**Ключевые связи с диаграммой:**
*   **Orders History Service** — отдельный контейнер, реализующий CQRS Query Side.
*   **Orders History DB (ClickHouse)** — оптимизированное хранилище для read-операций.
*   **Event Bus (Kafka)** — канал получения событий от сервисов ядра (`Order`, `Payment`, `Delivery` и др.).

---

### <a name="_u8xz25hbrgql"></a>**Нефункциональные требования**

Ключевые нефункциональные и архитектурно значимые требования к сценарию истории заказов.

**Ключевые нефункциональные и архитектурно значимые требования к сценарию «История заказов»**

| № | Требование |
|:-:|:---|
| **A. Производительность** |
| 1 | **Латентность:** 98-й перцентиль времени ответа интерфейса — не более **0.3 секунды**, 99.99-й перцентиль — не более **1 секунды** для основных запросов на получение истории заказов. |
| **B. Масштабируемость и нагрузка** |
| 2 | **Обработка пиковой нагрузки:** Система должна масштабироваться для обработки **свыше 40 000 новых заказов в день** при высокой доле read-запросов, так как сценарий истории заказов является одним из самых часто вызываемых. |
| 3 | **Изоляция read/write нагрузок:** Нагрузка от чтения истории заказов должна быть отделена от write-нагрузки основных сервисов (`Order`, `Payment`, `Delivery`), чтобы не оказывать влияния на критичные операции оформления и обработки заказов. |
| **C. Архитектурная гибкость и стратегия интеграции** |
| 4 | **Поддержка многоканальности:** Архитектура должна быть рассчитана на обслуживание различных каналов (мобильное приложение, веб, чат-боты, голосовые ассистенты) и будущих B2B API. Должна быть предусмотрена возможность адаптации API под разные клиенты без изменения внутренней логики микросервисов. |
| 5 | **Событийно-ориентированная архитектура:** Для построения агрегированной read-модели должны использоваться доменные события, публикуемые сервисами предметной области. |
| **D. Управление данными и консистентность** |
| 6 | **Гибкость read-модели:** Должна быть обеспечена возможность лёгкого расширения read-модели новыми полями и создания различных представлений данных (для аналитики, рекомендательных систем, отчётности) без существенного воздействия на существующую логику write-стороны. |
| 7 | **Модель консистентности:** Для истории заказов допустима **eventual consistency** (согласованность в конечном счёте). Обновления могут появляться с задержкой в пределах **нескольких секунд**, что является приемлемым компромиссом для достижения высокой производительности и доступности. |
| **E. Стратегическое развитие** |
| 8 | **Подготовка к глобальному развёртыванию:** Архитектура должна предусматривать возможность тиражирования read-модели в разные географические регионы и построения региональных проекций для поддержки будущей мультирегиональности. |

---

### <a name="_qmphm5d6rvi3"></a>**Решение**

#### Выбранный подход

##### Архитектурный подход (CQRS + Event Sourcing):
Для эффективной работы с историческими данными и сложными агрегациями используется отдельный Read Model (модель чтения) в сервисе Orders History Service.

**Write Model (Модель записи)**: Основные сервисы (Order, Payment, Delivery и т.д.) обрабатывают команды и публикуют события в Event Bus.

**Read Model (Модель чтения)**: Orders History Service подписывается на все релевантные события, денормализует их и сохраняет в оптимизированную для чтения БД (ClickHouse). Это позволяет выполнять быстрые и сложные запросы к истории без нагрузки на транзакционные БД основных сервисов.

**Описание ключевых компонентов и их доработки:**

**Orders History Service (Новый):**

Назначение: CQRS Query-side сервис. Агрегирует данные из событий в удобную для чтения структуру.

**Эндпоинты (REST):**

GET /history – список заказов пользователя (пагинация, фильтры по дате/статусу).

GET /history/{orderId} – детальная информация по конкретному заказу.

**Подписки на события (Kafka Consumer):**

order.events (OrderCreated, OrderStatusChanged)

payment.events (PaymentSucceeded, PaymentFailed)

delivery.events (DeliveryStatusChanged)

catalog.events (ProductUpdated – для актуализации названий/цен товаров в истории).

#### Логика
При получении события обновляет соответствующую запись в **Orders History DB**. Например, при DeliveryStatusChanged обновляет статус доставки и дату.

**Order Service (Доработка)**:

Добавляет эндпоинт для генерации чека (GET /orders/{id}/receipt).

Добавляет эндпоинт для повторения заказа (POST /orders/{id}/reorder), который возвращает список товаров. (Логика добавления в корзину остается за Cart Service).

Гарантированно публикует событие OrderStatusChanged при финальных статусах ("Доставлен", "Отменен").

**API Gateway (Доработка)**:

Добавляет маршрутизацию запросов на просмотр истории (/api/v1/orders/history/**) к новому Orders History Service.

Проксирует запросы на скачивание чека и повтор заказа в Order Service.

**SPA / Мобильное приложение (Доработка UI/UX)**:

Новый экран/раздел "История заказов" с кратким списком.

Детальный экран заказа с вкладками/секциями: "Состав", "Оплата", "Доставка".

Кнопки действий: "Скачать чек", "Заказать снова", "Оставить отзыв" (на каждом товаре).

**Поток данных (Data Flow)**:

Запрос истории: Buyer -> SPA -> API Gateway -> Orders History Service -> Orders History DB.

Обновление истории (асинхронно): Order Service -> (публикует OrderCreated) -> Event Bus -> (потребляет) Orders History Service -> (обновляет) Orders History DB

---

### <a name="_bjrr7veeh80c"></a>**Альтернативы**

#### Подход: Гибридное решение с использованием существующих сервисов + оптимизация
1. Ключевая идея: Не вводить новый Orders History Service, а расширить существующие сервисы и использовать комбинацию кэширования, материализованных представлений и оптимизированных API.

2. Основные принципы:

Минимальные изменения: Используем существующие сервисы с расширенными возможностями

**Read-through кэш**: Redis как агрегирующий кэш для истории заказов

**Агрегирующий API Gateway**: Композиция данных из нескольких сервисов

**Оптимизированные запросы**: Специальные эндпоинты для быстрого чтения

**Преимущества этого подхода**:

| Преимущество	| Описание |
|:-:|:---|
| Быстрое внедрение	| Можно реализовать за 2-3 недели |
| Минимальные риски	| Не меняем основную архитектуру |
| Используем существующее	| Redis, Kafka, сервисы уже есть |
| Простое масштабирование	| History Aggregator - stateless, можно масштабировать горизонтально |
| Легкий откат	| Если что-то пойдет не так, просто отключаем агрегатор |

---

### **Недостатки, ограничения и риски основного решения**

#### **1. Eventual Consistency Read-Модели**
**Проблема:** Данные в истории заказов обновляются с задержкой из-за асинхронной обработки событий.

**Конкретные риски:**
- **UX противоречия:** Пользователь видит расхождение между актуальным статусом заказа (например, в push-уведомлении о доставке) и данными в истории
- **Финансовые несоответствия:** Суммы, статусы оплаты и доставки могут отображаться некорректно в течение нескольких секунд/минут после фактического изменения
- **Ограничения бизнес-процессов:** Нельзя использовать историю заказов для синхронных операций (проверка статуса для поддержки клиентов, мгновенное оформление возвратов)

**Меры компенсации:**
- Обязательная настройка UX с индикацией "данные обновляются"
- Мониторинг задержки обработки событий (Kafka lag, processing time)
- Для критичных сценариев - fallback на прямые запросы к source-сервисам

#### **2. Дополнительная Инфраструктурная Сложность**
**Новые компоненты для поддержки:**
```
Orders History Service (микросервис .NET)    
ClickHouse кластер                           
Дополнительные Kafka топики/партиции        
```

#### **3. Сложность Логики Проекций и Согласованности Данных**
**Критические риски:**

| **Тип ошибки** | **Последствие** | **Сложность исправления** |
|----------------|-----------------|---------------------------|
| Ошибка в обработчике событий | Расхождение данных | Высокая (требует пересборки проекций) |
| Потеря события | Пропуск заказа в истории | Средняя (replay событий) |
| Race conditions | Некорректная последовательность обработки | Высокая (сложная отладка) |
| Ошибки миграции схемы | Несовместимость версий | Критическая (простой сервиса) |

**Необходимые компенсационные механизмы:**
- Регулярные проверки консистентности между source и projection
- Механизм пересборки read-модели из событий
- Dead letter queues для проблемных событий
- Подробное логирование и трассировка каждого этапа обработки

#### **4. Жесткие Требования к Контрактам Событий**
**Проблемы координации:**
- Любое изменение в структуре событий требует синхронного обновления `Orders History Service`
- Несовместимые изменения могут привести к остановке обработки событий
- Необходимость поддержки множества версий событий усложняет код

**Решение требует:**
1. Стандартизированного подхода к versioning событий
2. Механизмов обратной совместимости
3. Координации релизов между сервисами
4. Регрессионного тестирования обработчиков событий

#### **5. Гибридный Подход: Event-Driven без Full Event Sourcing**
**Архитектурные компромиссы:**
- ✓ Используем события для обновления read-модели
- ✗ Но не имеем единого Event Store как источника истины
- ✗ Прямые изменения в базах source-сервисов не отражены в событиях
- ✗ Невозможность полного replay системы из событий

**Риски при эволюции архитектуры:**
- Дальнейший переход к full Event Sourcing потребует значительной переработки
- Существующие данные потребуют миграции
- Накопленные технические долги в обработке событий

#### **6. Риск Недооценки Future Requirements**
**Текущие возможности ClickHouse:**
- Быстрые агрегации по временным диапазонам
- Эффективные группировки и сортировки
- Хорошая производительность при денормализованной схеме

**Потенциальные будущие требования, которые могут вызвать проблемы:**
- **Сложные JOIN** между историей заказов и другими доменами
- **Полнотекстовый поиск** по товарам в заказах
- **Геопространственные запросы** (заказы по регионам)
- **Реaltime аналитика** с sub-second latency требованиями
- **GDPR compliance** с запросами на удаление/экспорт данных пользователя
